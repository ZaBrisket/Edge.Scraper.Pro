import type { Handler } from '@netlify/functions';
import * as asposewordscloud from 'asposewordscloud';
import { limitOrThrow, clientIp } from '../../src/lib/rate-limit';

export const handler: Handler = async (event, context) => {
  try {
    if (process.env.KILL_SWITCH === '1') {
      return res(503, { error: 'Service temporarily unavailable', code: 'KILLED' });
    }

    await limitOrThrow(`nda-export-aspose:${clientIp(event, context)}`, { points: 6, window: '60 s' });

    if (event.httpMethod !== 'POST') {
      return res(405, { error: 'Method Not Allowed' });
    }

    const { originalBase64, proposedDocxBase64, resultFileName = 'nda_redlines.docx', author = 'EdgeScraperPro NDA Bot' } =
      JSON.parse(event.body || '{}');

    if (!originalBase64 || !proposedDocxBase64) {
      return res(400, { error: 'Missing originalBase64/proposedDocxBase64' });
    }

    const clientId = process.env.ASP_WORDS_CLIENT_ID!;
    const clientSecret = process.env.ASP_WORDS_CLIENT_SECRET!;
    if (!clientId || !clientSecret) {
      return res(503, { error: 'Aspose unavailable', code: 'ASPOSE_UNAVAILABLE' });
    }

    const wordsApi = new asposewordscloud.WordsApi(clientId, clientSecret);

    // Upload with retries
    const originalName = `orig-${Date.now()}.docx`;
    const revisedName = `revised-${Date.now()}.docx`;
    await retry(async () => upload(wordsApi, originalName, Buffer.from(originalBase64, 'base64')));
    await retry(async () => upload(wordsApi, revisedName, Buffer.from(proposedDocxBase64, 'base64')));

    // Compare, result saved server-side; then decorate and download
    const compareData = new asposewordscloud.CompareData({
      Author: author,
      DateTime: new Date().toISOString()
    });

    const outName = `out-${resultFileName}`;
    await retry(async () =>
      wordsApi.compareDocument(
        new asposewordscloud.CompareDocumentRequest({
          name: originalName,
          compareData,
          comparingDocument: revisedName,
          destFileName: outName
        })
      )
    );

    // Watermark & metadata (best-effort)
    try {
      await wordsApi.insertWatermarkText({
        name: outName,
        watermarkText: { Text: 'NOT LEGAL ADVICE — DRAFT', RotationAngle: -45 }
      } as any);
      await wordsApi.updateDocumentProperties({
        name: outName,
        properties: {
          list: [
            { name: 'Category', value: 'Automated Review — Not Legal Advice' },
            { name: 'Comments', value: 'Generated by EdgeScraperPro NDA Reviewer' }
          ]
        }
      } as any);
    } catch {}

    const result = await retry(async () => wordsApi.downloadFile(new asposewordscloud.DownloadFileRequest({ path: outName })));

    return {
      statusCode: 200,
      headers: {
        'Content-Type': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        'Content-Disposition': `attachment; filename="${resultFileName}"`
      },
      body: Buffer.from(result).toString('base64'),
      isBase64Encoded: true
    };
  } catch (err: any) {
    console.error('[nda-export-docx error]', err);
    if (err.code === 'ASPOSE_UNAVAILABLE' || err.statusCode === 503) {
      return res(503, { error: 'Aspose service unavailable', code: 'ASPOSE_UNAVAILABLE' });
    }
    return res(500, { error: 'Export failed' });
  }
};

export async function retry<T>(fn: () => Promise<T>, max = 3, base = 300): Promise<T> {
  let lastErr: any;
  for (let i = 0; i < max; i++) {
    try {
      return await fn();
    } catch (e: any) {
      lastErr = e;
      const status = e?.statusCode || e?.status || 0;
      if (![401, 403, 429].includes(status) && status < 500) break;
      await new Promise((r) => setTimeout(r, base * Math.pow(2, i)));
    }
  }
  const err: any = new Error('Aspose unavailable');
  err.statusCode = 503;
  err.code = 'ASPOSE_UNAVAILABLE';
  throw err;
}

async function upload(api: asposewordscloud.WordsApi, name: string, buf: Buffer) {
  await api.uploadFile(new asposewordscloud.UploadFileRequest({ fileContent: buf, path: name }));
}

function res(statusCode: number, body: any) {
  return {
    statusCode,
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body)
  };
}
