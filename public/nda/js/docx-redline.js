// Enhanced .docx redline generation with tracked changes
import {
  Document, Packer, Paragraph, TextRun,
  CommentRangeStart, CommentRangeEnd, CommentReference, Comment,
  HeadingLevel, InsertedTextRun, DeletedTextRun
} from "https://cdn.jsdelivr.net/npm/docx@8.5.0/build/index.mjs";

/**
 * Build standard redlines document
 * @param {{ fullText:string, results:Array, meta:object, sourceFormat:string }} params
 * @returns {Promise<Blob>}
 */
export async function buildRedlinesDoc({ fullText, results, meta, sourceFormat }) {
  if (!Document || !Packer) {
    throw new Error("DOCX export unavailable: required libraries did not load.");
  }
  
  const doc = new Document({
    creator: "EdgeScraperPro NDA Reviewer 2.0",
    title: "NDA Redlines",
    features: {
      trackChanges: true
    },
    sections: []
  });

  const children = [];
  
  // Header
  children.push(new Paragraph({ 
    text: "NDA Review — Comprehensive Redlines", 
    heading: HeadingLevel.TITLE 
  }));
  
  // Metadata
  const metaLines = [
    `Source: ${meta?.filename || "—"}`,
    `Format: ${sourceFormat || "text"}`,
    `Size: ${meta?.filesize || "—"}`,
    `Processed: ${meta?.processedAt || "—"}`,
    `Processing Time: ${typeof meta?.processingMs === "number" ? meta.processingMs + " ms" : "—"}`,
    `Context-Aware Mode: ${meta?.contextAware ? "Enabled" : "Disabled"}`
  ];
  
  for (const line of metaLines) {
    children.push(new Paragraph(line));
  }
  
  children.push(new Paragraph(""));
  children.push(new Paragraph({
    children: [
      new TextRun({
        text: "Generated by EdgeScraperPro NDA Reviewer 2.0. ",
        italics: true
      }),
      new TextRun({
        text: "Not legal advice.",
        italics: true,
        bold: true
      })
    ]
  }));
  
  children.push(new Paragraph(""));
  children.push(new Paragraph({ 
    text: "Document Text with Comments", 
    heading: HeadingLevel.HEADING_1 
  }));
  
  // Split text into paragraphs for better comment anchoring
  const lines = (fullText || "").split(/\n+/);
  const paras = lines.map(line => 
    new Paragraph({ 
      children: [new TextRun(line || " ")],
      spacing: { after: 120 }
    })
  );

  // Add comments for issues
  let commentId = 1;
  const failedResults = results.filter(r => r.status !== "pass");
  
  for (const result of failedResults) {
    const evidence = result.evidence;
    if (!evidence?.text) continue;
    
    // Find paragraph containing evidence
    const snippet = evidence.text.slice(0, Math.min(50, evidence.text.length)).toLowerCase();
    let targetIdx = lines.findIndex(l => l.toLowerCase().includes(snippet));
    if (targetIdx < 0) targetIdx = 0;
    
    const targetPara = paras[targetIdx];
    
    // Add comment anchors
    const start = new CommentRangeStart(commentId);
    const end = new CommentRangeEnd(commentId);
    targetPara.children.unshift(start);
    targetPara.children.push(end);
    targetPara.children.push(new CommentReference(commentId));
    
    // Create comment with severity indicator
    const severityIndicator = result.adjustedSeverity 
      ? `[Adjusted Severity: ${result.adjustedSeverity}]` 
      : `[Severity: ${result.severity}]`;
    
    const comment = new Comment({
      id: commentId,
      author: "EdgeScraperPro",
      date: new Date(),
      children: [
        new Paragraph({ 
          children: [ 
            new TextRun({ 
              text: `${severityIndicator} [${result.category}] ${result.title}`, 
              bold: true 
            }) 
          ]
        }),
        ...(evidence?.text ? [ 
          new Paragraph({ 
            children: [ 
              new TextRun({ 
                text: `Evidence: ${evidence.text}`,
                italics: true 
              }) 
            ]
          }) 
        ] : []),
        ...(result.recommendation ? [ 
          new Paragraph({ 
            children: [ 
              new TextRun({ 
                text: `Recommendation: ${result.recommendation}` 
              }) 
            ]
          }) 
        ] : [])
      ]
    });
    
    doc.addComment(comment);
    commentId++;
  }

  children.push(...paras);
  
  // Summary section
  children.push(new Paragraph(""));
  children.push(new Paragraph({ 
    text: "Checklist Summary", 
    heading: HeadingLevel.HEADING_1 
  }));
  
  // Group results by severity
  const highSeverity = results.filter(r => (r.adjustedSeverity || r.severity) >= 8);
  const medSeverity = results.filter(r => {
    const sev = r.adjustedSeverity || r.severity;
    return sev >= 5 && sev < 8;
  });
  const lowSeverity = results.filter(r => (r.adjustedSeverity || r.severity) < 5);
  
  if (highSeverity.length > 0) {
    children.push(new Paragraph({ 
      text: "High Priority Issues", 
      heading: HeadingLevel.HEADING_2 
    }));
    
    for (const r of highSeverity) {
      children.push(new Paragraph({
        children: [
          new TextRun({ text: `• `, bold: true }),
          new TextRun({ text: `[${r.status.toUpperCase()}] ` }),
          new TextRun({ text: r.title })
        ],
        indent: { left: 360 }
      }));
      
      if (r.recommendation) {
        children.push(new Paragraph({
          children: [
            new TextRun({ 
              text: `  → ${r.recommendation}`,
              italics: true
            })
          ],
          indent: { left: 720 }
        }));
      }
    }
  }
  
  if (medSeverity.length > 0) {
    children.push(new Paragraph({ 
      text: "Medium Priority Issues", 
      heading: HeadingLevel.HEADING_2 
    }));
    
    for (const r of medSeverity) {
      children.push(new Paragraph({
        children: [
          new TextRun({ text: `• ${r.title}` })
        ],
        indent: { left: 360 }
      }));
    }
  }
  
  if (lowSeverity.length > 0) {
    children.push(new Paragraph({ 
      text: "Low Priority Issues", 
      heading: HeadingLevel.HEADING_2 
    }));
    
    for (const r of lowSeverity) {
      children.push(new Paragraph({
        children: [
          new TextRun({ text: `• ${r.title}` })
        ],
        indent: { left: 360 }
      }));
    }
  }

  doc.addSection({ children });
  return await Packer.toBlob(doc);
}

/**
 * Build interactive redlines document with tracked changes
 * @param {{ fullText:string, results:Array, meta:object, sourceFormat:string, contextScores:Map }} params
 * @returns {Promise<Blob>}
 */
export async function buildInteractiveRedlinesDoc({ 
  fullText, 
  results, 
  meta, 
  sourceFormat,
  contextScores 
}) {
  if (!Document || !Packer) {
    throw new Error("DOCX export unavailable: required libraries did not load.");
  }
  
  const doc = new Document({
    creator: "EdgeScraperPro NDA Reviewer 2.0",
    title: "NDA Interactive Redlines",
    features: {
      trackChanges: true,
      updateFields: true
    },
    sections: []
  });

  const children = [];
  
  // Cover page
  children.push(new Paragraph({ 
    text: "NDA Review — Selected Redlines with Track Changes", 
    heading: HeadingLevel.TITLE 
  }));
  
  children.push(new Paragraph(""));
  children.push(new Paragraph({
    children: [
      new TextRun({
        text: `Generated: ${new Date().toLocaleDateString()}`,
        italics: true
      })
    ]
  }));
  
  children.push(new Paragraph({
    children: [
      new TextRun({
        text: `Selected Issues: ${results.length}`,
        bold: true
      })
    ]
  }));
  
  children.push(new Paragraph(""));
  
  // Document with inline track changes
  children.push(new Paragraph({ 
    text: "Redlined Document", 
    heading: HeadingLevel.HEADING_1 
  }));
  
  // Process text with redlines
  const replacements = [];
  
  // Collect all replacements to apply
  for (const result of results) {
    if (result.evidence?.text && result.recommendation) {
      const contextScore = contextScores?.get(result.id);
      
      // Generate replacement text based on recommendation
      const replacement = generateReplacementText(
        result.evidence.text,
        result.recommendation,
        contextScore
      );
      
      if (replacement) {
        replacements.push({
          original: result.evidence.text,
          replacement: replacement.text,
          explanation: replacement.explanation,
          position: fullText.indexOf(result.evidence.text)
        });
      }
    }
  }
  
  // Sort replacements by position (reverse order to maintain indices)
  replacements.sort((a, b) => b.position - a.position);
  
  // Build document with track changes
  const textSegments = [];
  let lastEnd = fullText.length;
  
  for (const repl of replacements) {
    if (repl.position >= 0) {
      // Add text after this replacement
      if (repl.position + repl.original.length < lastEnd) {
        textSegments.unshift({
          type: 'normal',
          text: fullText.slice(repl.position + repl.original.length, lastEnd)
        });
      }
      
      // Add replacement with track changes
      textSegments.unshift({
        type: 'replacement',
        deleted: repl.original,
        inserted: repl.replacement,
        explanation: repl.explanation
      });
      
      lastEnd = repl.position;
    }
  }
  
  // Add remaining text at the beginning
  if (lastEnd > 0) {
    textSegments.unshift({
      type: 'normal',
      text: fullText.slice(0, lastEnd)
    });
  }
  
  // Create paragraphs with track changes
  for (const segment of textSegments) {
    if (segment.type === 'normal') {
      // Split into paragraphs
      const lines = segment.text.split('\n');
      for (const line of lines) {
        if (line.trim()) {
          children.push(new Paragraph({
            children: [new TextRun(line)],
            spacing: { after: 120 }
          }));
        }
      }
    } else if (segment.type === 'replacement') {
      // Create paragraph with tracked changes
      const para = new Paragraph({
        children: [
          new DeletedTextRun({
            text: segment.deleted,
            author: "EdgeScraperPro",
            date: new Date()
          }),
          new TextRun(" "),
          new InsertedTextRun({
            text: segment.inserted,
            author: "EdgeScraperPro", 
            date: new Date()
          })
        ],
        spacing: { after: 120 }
      });
      
      children.push(para);
      
      // Add explanation as comment if available
      if (segment.explanation) {
        children.push(new Paragraph({
          children: [
            new TextRun({
              text: `[Rationale: ${segment.explanation}]`,
              italics: true,
              color: "666666"
            })
          ],
          indent: { left: 720 }
        }));
      }
    }
  }
  
  // Summary of changes
  children.push(new Paragraph(""));
  children.push(new Paragraph({ 
    text: "Summary of Applied Changes", 
    heading: HeadingLevel.HEADING_1 
  }));
  
  for (const result of results) {
    const contextScore = contextScores?.get(result.id);
    
    children.push(new Paragraph({
      children: [
        new TextRun({ text: `• `, bold: true }),
        new TextRun({ text: result.title })
      ],
      indent: { left: 360 }
    }));
    
    if (contextScore?.substantialCompliance) {
      children.push(new Paragraph({
        children: [
          new TextRun({
            text: `  ✓ Substantial compliance detected - minimal changes applied`,
            color: "008000",
            italics: true
          })
        ],
        indent: { left: 720 }
      }));
    } else if (result.recommendation) {
      children.push(new Paragraph({
        children: [
          new TextRun({
            text: `  → ${result.recommendation}`,
            italics: true
          })
        ],
        indent: { left: 720 }
      }));
    }
  }
  
  doc.addSection({ children });
  return await Packer.toBlob(doc);
}

/**
 * Generate replacement text based on recommendation
 * @param {string} original - Original text
 * @param {string} recommendation - Recommendation text
 * @param {Object} contextScore - Context score data
 * @returns {Object} Replacement text and explanation
 */
function generateReplacementText(original, recommendation, contextScore) {
  // If substantial compliance, make minimal changes
  if (contextScore?.substantialCompliance) {
    return null; // No replacement needed
  }
  
  // Map common recommendations to replacements
  const replacementMap = {
    'perpetual': '2 years from the date of disclosure',
    'in perpetuity': '2 years from the date of disclosure',
    'indefinite': '2 years from the date of disclosure',
    'non-solicit': '[REMOVED - Move to separate agreement]',
    'non-compete': '[REMOVED - Move to separate agreement]',
    'assigns all right': 'maintains ownership of all intellectual property',
    'transfers ownership': 'licenses on a non-exclusive basis',
    'one-way': 'mutual',
    'unilateral': 'bilateral',
    'residuals': '[REMOVED - No residuals permitted]'
  };
  
  // Check if original contains problematic terms
  for (const [term, replacement] of Object.entries(replacementMap)) {
    if (original.toLowerCase().includes(term)) {
      const pattern = new RegExp(term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
      return {
        text: original.replace(pattern, replacement),
        explanation: `Replaced \"${term}\" per Edgewater requirements`
      };
    }
  }
  
  // Generic replacement based on recommendation keywords
  if (recommendation.toLowerCase().includes('remove')) {
    return {
      text: '[PROVISION REMOVED]',
      explanation: recommendation
    };
  }
  
  if (recommendation.toLowerCase().includes('add')) {
    return {
      text: original + ' ' + extractAdditionText(recommendation),
      explanation: recommendation
    };
  }
  
  return null;
}

/**
 * Extract text to add from recommendation
 * @param {string} recommendation - Recommendation text
 * @returns {string} Text to add
 */
function extractAdditionText(recommendation) {
  // Extract quoted text from recommendation
  const quotedMatch = recommendation.match(/['"](.*?)['"]/);
  if (quotedMatch) {
    return quotedMatch[1];
  }
  
  // Common additions
  if (recommendation.includes('mutual')) {
    return 'Each party shall maintain the confidentiality of the other party\'s Confidential Information.';
  }
  
  if (recommendation.includes('return')) {
    return 'Upon request or termination, all Confidential Information shall be returned or destroyed.';
  }
  
  if (recommendation.includes('equitable')) {
    return 'Breach may cause irreparable harm and injunctive relief may be appropriate.';
  }
  
  return '[ADDITION REQUIRED - See recommendation]';
}
