import fs from 'node:fs';
import * as asposewordscloud from 'asposewordscloud';

export async function retry<T>(fn: () => Promise<T>, max = 3, base = 300): Promise<T> {
  let lastErr: any;
  for (let attempt = 0; attempt < max; attempt++) {
    try {
      return await fn();
    } catch (err: any) {
      lastErr = err;
      const status = err?.statusCode || err?.status || 0;
      if (![401, 403, 429].includes(status) && status < 500) {
        break;
      }
      await new Promise(resolve => setTimeout(resolve, base * Math.pow(2, attempt)));
    }
  }
  const error: any = new Error('Aspose unavailable');
  error.statusCode = 503;
  error.code = 'ASPOSE_UNAVAILABLE';
  error.cause = lastErr;
  throw error;
}

async function upload(api: asposewordscloud.WordsApi, name: string, filePath: string) {
  await api.uploadFile(
    new asposewordscloud.UploadFileRequest({
      fileContent: fs.createReadStream(filePath),
      path: name,
    })
  );
}

export interface GenerateTrackedChangesInput {
  originalPath: string;
  revisedPath: string;
  resultFileName: string;
  author: string;
}

export async function generateTrackedChanges({
  originalPath,
  revisedPath,
  resultFileName,
  author,
}: GenerateTrackedChangesInput): Promise<Buffer> {
  const clientId = process.env.ASP_WORDS_CLIENT_ID;
  const clientSecret = process.env.ASP_WORDS_CLIENT_SECRET;
  if (!clientId || !clientSecret) {
    const err: any = new Error('Aspose unavailable');
    err.statusCode = 503;
    err.code = 'ASPOSE_UNAVAILABLE';
    throw err;
  }

  const wordsApi = new asposewordscloud.WordsApi(clientId, clientSecret);
  const originalName = `orig-${Date.now()}-${Math.random().toString(16).slice(2)}.docx`;
  const revisedName = `revised-${Date.now()}-${Math.random().toString(16).slice(2)}.docx`;

  await Promise.all([
    retry(() => upload(wordsApi, originalName, originalPath)),
    retry(() => upload(wordsApi, revisedName, revisedPath)),
  ]);

  const compareData = new asposewordscloud.CompareData({
    author,
    dateTime: new Date().toISOString(),
  } as any);

  const outName = `out-${resultFileName}`;
  await retry(() =>
    wordsApi.compareDocument(
      new asposewordscloud.CompareDocumentRequest({
        name: originalName,
        compareData,
        comparingDocument: revisedName,
        destFileName: outName,
      } as any)
    )
  );

  try {
    await (wordsApi as any).insertWatermarkText({
      name: outName,
      watermarkText: { Text: 'NOT LEGAL ADVICE — DRAFT', RotationAngle: -45 },
    } as any);
    await (wordsApi as any).updateDocumentProperties({
      name: outName,
      properties: {
        list: [
          { name: 'Category', value: 'Automated Review — Not Legal Advice' },
          { name: 'Comments', value: 'Generated by EdgeScraperPro NDA Reviewer' },
        ],
      },
    } as any);
  } catch (err) {
    console.warn('[aspose watermark warning]', err);
  }

  const result = (await retry(() =>
    wordsApi.downloadFile(new asposewordscloud.DownloadFileRequest({ path: outName }))
  )) as unknown;

  if (result instanceof Buffer) return result;
  if (result instanceof Uint8Array) return Buffer.from(result);
  if (result && typeof (result as any).arrayBuffer === 'function') {
    return Buffer.from(await (result as any).arrayBuffer());
  }
  return Buffer.from(result as ArrayBuffer);
}
